{"version":3,"sources":["../../src/pages/product/product.module.ts","../../node_modules/ionic2-super-tabs/dist/components/super-tabs.js","../../node_modules/ionic2-super-tabs/dist/providers/super-tabs-controller.js","../../node_modules/ionic2-super-tabs/dist/index.js","../../node_modules/ionic2-super-tabs/dist/components/super-tab.js","../../node_modules/ionic2-super-tabs/dist/components/super-tabs-toolbar.js","../../node_modules/ionic2-super-tabs/dist/super-tabs-pan-gesture.js","../../node_modules/ionic2-super-tabs/dist/components/super-tab-button.js","../../node_modules/ionic2-super-tabs/dist/components/super-tabs-container.js","../../node_modules/rxjs/scheduler/async.js","../../src/pages/product/product.ts","../../node_modules/rxjs/add/observable/fromEvent.js","../../node_modules/rxjs/add/observable/merge.js","../../node_modules/rxjs/add/operator/debounceTime.js","../../node_modules/rxjs/operator/debounceTime.js","../../node_modules/rxjs/scheduler/AsyncAction.js","../../node_modules/rxjs/scheduler/Action.js","../../node_modules/rxjs/scheduler/AsyncScheduler.js","../../node_modules/rxjs/Scheduler.js","../../node_modules/rxjs/operators/debounceTime.js","../../node_modules/ionic2-super-tabs/dist/super-tabs.module.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAuC;AACO;AACR;AACY;AAWlD;IAAA;IACA,CAAC;IADY,iBAAiB;QAT7B,uEAAQ,CAAC;YACR,YAAY,EAAE;gBACZ,6DAAW;aACZ;YACD,OAAO,EAAE;gBACP,sEAAe,CAAC,QAAQ,CAAC,6DAAW,CAAC;gBACrC,0EAAe,CAAC,OAAO,EAAE;aAC1B;SACF,CAAC;OACW,iBAAiB,CAC7B;IAAD,wBAAC;CAAA;AAD6B;;;;;;;;;ACd9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;AACA;AACA,aAAa,6BAA6B,0BAA0B,aAAa,EAAE,qBAAqB;AACxG,gBAAgB,qDAAqD,oEAAoE,aAAa,EAAE;AACxJ,sBAAsB,sBAAsB,qBAAqB,GAAG;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,kCAAkC,SAAS;AAC3C,kCAAkC,WAAW,UAAU;AACvD,yCAAyC,cAAc;AACvD;AACA,6GAA6G,OAAO,UAAU;AAC9H,gFAAgF,iBAAiB,OAAO;AACxG,wDAAwD,gBAAgB,QAAQ,OAAO;AACvF,8CAA8C,gBAAgB,gBAAgB,OAAO;AACrF;AACA,iCAAiC;AACjC;AACA;AACA,SAAS,YAAY,aAAa,OAAO,EAAE,UAAU,WAAW;AAChE,mCAAmC,SAAS;AAC5C;AACA;AACkJ;AAChC;AACrE;AACW;AACI;AACa;AACJ;AAC9B;AACJ;AACK;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,6BAA6B,mEAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2DAAU;AACtB,YAAY,2DAAU;AACtB;AACA;AACA;AACA;AACA;AACA,4BAA4B,2DAAU;AACtC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,2FAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,uCAAuC,EAAE;AACzF;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kBAAkB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,8CAA8C,2FAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,4BAA4B,EAAE;AACzE;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,+BAA+B,+BAA+B;AAC9D;AACA,uBAAuB,6CAA6C;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+BAA+B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,4BAA4B,EAAE;AAClF;AACA;AACA,+CAA+C,4BAA4B,EAAE;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iDAAiD,EAAE;AACtF;AACA;AACA,SAAS,OAAO,gEAAS;AACzB;AACA;AACA,mCAAmC,0EAAiB;AACpD;AACA;AACA,qCAAqC,+DAAQ;AAC7C,yCAAyC,2EAAU,cAAc,kBAAkB,EAAE;AACrF;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,4CAA4C;AAC5C,SAAS,OAAO,oEAAa,gBAAgB,OAAO,+DAAQ,EAAE,IAAI;AAClE,SAAS,OAAO,qEAAc,gBAAgB,OAAO,+DAAQ,EAAE,IAAI;AACnE,SAAS,OAAO,0DAAG,GAAG;AACtB,SAAS,OAAO,iEAAU,GAAG;AAC7B,SAAS,OAAO,gEAAS,GAAG;AAC5B,SAAS,OAAO,6FAAmB,GAAG;AACtC,SAAS,OAAO,iEAAU,GAAG;AAC7B,SAAS,OAAO,oEAAa,GAAG;AAChC,SAAS,OAAO,+DAAQ,GAAG;AAC3B,MAAM;AACN;AACA,+BAA+B,OAAO,4DAAK,EAAE;AAC7C,0BAA0B,OAAO,4DAAK,EAAE;AACxC,4BAA4B,OAAO,4DAAK,EAAE;AAC1C,wBAAwB,OAAO,4DAAK,EAAE;AACtC,oBAAoB,OAAO,4DAAK,EAAE;AAClC,gBAAgB,OAAO,4DAAK,EAAE;AAC9B,kBAAkB,OAAO,4DAAK,EAAE;AAChC,oBAAoB,OAAO,4DAAK,EAAE;AAClC,8BAA8B,OAAO,4DAAK,EAAE;AAC5C,wBAAwB,OAAO,4DAAK,EAAE;AACtC,2BAA2B,OAAO,4DAAK,EAAE;AACzC,uBAAuB,OAAO,6DAAM,EAAE;AACtC,qBAAqB,OAAO,iEAAS,SAAS,6EAAgB,IAAI;AAClE,2BAA2B,OAAO,iEAAS,SAAS,iFAAkB,IAAI;AAC1E;AACA;AACA,CAAC;AACoB;AACrB;AACA,sC;;;;;;;;ACjoBA;AAAA;AAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,2BAA2B,EAAE;AAC1F;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO,iEAAU,EAAE;AAC5B;AACA;AACA,sDAAsD,WAAW;AACjE;AACA,CAAC;AAC8B;AAC/B,iD;;;;;;;;AC9EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAuC;AACC;AACU;AACd;AACpC,iC;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD;AACA;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;AACA;AACA,aAAa,6BAA6B,0BAA0B,aAAa,EAAE,qBAAqB;AACxG,gBAAgB,qDAAqD,oEAAoE,aAAa,EAAE;AACxJ,sBAAsB,sBAAsB,qBAAqB,GAAG;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,kCAAkC,SAAS;AAC3C,kCAAkC,WAAW,UAAU;AACvD,yCAAyC,cAAc;AACvD;AACA,6GAA6G,OAAO,UAAU;AAC9H,gFAAgF,iBAAiB,OAAO;AACxG,wDAAwD,gBAAgB,QAAQ,OAAO;AACvF,8CAA8C,gBAAgB,gBAAgB,OAAO;AACrF;AACA,iCAAiC;AACjC;AACA;AACA,SAAS,YAAY,aAAa,OAAO,EAAE,UAAU,WAAW;AAChE,mCAAmC,SAAS;AAC5C;AACA;AACoM;AAC7E;AAChC;AAC9C;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,qDAAqD,oCAAoC,EAAE;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,iBAAiB;AACxG;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO,gEAAS;AACzB;AACA;AACA,mCAAmC,0EAAiB;AACpD,iBAAiB,IAAI;AACrB;AACA;AACA,2CAA2C;AAC3C,SAAS,OAAO,8DAAS,GAAG;AAC5B,SAAS,OAAO,0DAAG,GAAG;AACtB,SAAS,OAAO,6DAAM,GAAG;AACzB,SAAS,OAAO,+DAAQ,GAAG;AAC3B,SAAS,OAAO,iEAAU,GAAG;AAC7B,SAAS,OAAO,6DAAM,GAAG;AACzB,SAAS,OAAO,+DAAQ,GAAG;AAC3B,SAAS,OAAO,+EAAwB,GAAG;AAC3C,SAAS,OAAO,wEAAiB,GAAG;AACpC,SAAS,OAAO,6GAAoB,GAAG;AACvC,SAAS,OAAO,mEAAY,GAAG;AAC/B,SAAS,OAAO,iEAAU,gBAAgB,OAAO,+DAAQ,EAAE,IAAI;AAC/D,SAAS,OAAO,oEAAa,GAAG;AAChC,SAAS,OAAO,wEAAiB,GAAG;AACpC,MAAM;AACN;AACA,mBAAmB,OAAO,4DAAK,EAAE;AACjC,kBAAkB,OAAO,4DAAK,EAAE;AAChC,kBAAkB,OAAO,4DAAK,EAAE;AAChC,wBAAwB,OAAO,4DAAK,EAAE;AACtC,mBAAmB,OAAO,4DAAK,iBAAiB;AAChD,mBAAmB,OAAO,4DAAK,EAAE;AACjC,8BAA8B,OAAO,4DAAK,EAAE;AAC5C,iBAAiB,OAAO,iEAAS,sBAAsB,OAAO,yEAAgB,EAAE,IAAI;AACpF;AACA;AACA,CAAC,CAAC,wEAAiB;AACC;AACpB,qC;;;;;;;;ACvOA;AAAA;AAAA;AAAA;AAAA;AAA0I;AAClF;AACQ;AACZ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mEAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oFAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS,OAAO,gEAAS;AACzB;AACA,6PAA6P,iCAAiC,4HAA4H,kWAAkW,iCAAiC;AAC7xB,mCAAmC,0EAAiB;AACpD,iBAAiB,IAAI;AACrB;AACA;AACA,mDAAmD;AACnD,SAAS,OAAO,iEAAU,GAAG;AAC7B,SAAS,OAAO,+DAAQ,GAAG;AAC3B,SAAS,OAAO,gEAAS,GAAG;AAC5B,SAAS,OAAO,oEAAa,GAAG;AAChC,MAAM;AACN;AACA,mBAAmB,OAAO,4DAAK,EAAE;AACjC,uBAAuB,OAAO,4DAAK,EAAE;AACrC,wBAAwB,OAAO,4DAAK,EAAE;AACtC,wBAAwB,OAAO,4DAAK,EAAE;AACtC,4BAA4B,OAAO,4DAAK,EAAE;AAC1C,yBAAyB,OAAO,4DAAK,EAAE;AACvC,oBAAoB,OAAO,4DAAK,EAAE;AAClC,2BAA2B,OAAO,4DAAK,EAAE;AACzC,uBAAuB,OAAO,6DAAM,EAAE;AACtC,wBAAwB,OAAO,oEAAY,SAAS,yEAAc,IAAI;AACtE,iCAAiC,OAAO,iEAAS,kCAAkC;AACnF,uBAAuB,OAAO,iEAAS,wBAAwB;AAC/D,2BAA2B,OAAO,iEAAS,yBAAyB;AACpE;AACA;AACA,CAAC;AAC2B;AAC5B,8C;;;;;;;;AC5IA;AAAA;AAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,aAAa,EAAE;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,qBAAqB,oFAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oFAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oFAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAC8B;AAC/B,kD;;;;;;;;ACtGA;AAAA;AAA+H;AAC/H;AACA;AACA;AACA;AACA,0BAA0B,mEAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO,gEAAS;AACzB;AACA,wLAAwL,SAAS,6DAA6D,SAAS;AACvQ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,qCAAqC,8EAAuB;AAC5D,mCAAmC,0EAAiB;AACpD,iBAAiB,IAAI;AACrB;AACA;AACA,iDAAiD;AACjD,SAAS,OAAO,iEAAU,GAAG;AAC7B,MAAM;AACN;AACA,sBAAsB,OAAO,4DAAK,EAAE;AACpC,mBAAmB,OAAO,4DAAK,EAAE;AACjC,kBAAkB,OAAO,4DAAK,EAAE;AAChC,mBAAmB,OAAO,4DAAK,EAAE;AACjC,wBAAwB,OAAO,4DAAK,EAAE;AACtC,mBAAmB,OAAO,4DAAK,EAAE;AACjC,oBAAoB,OAAO,6DAAM,EAAE;AACnC;AACA;AACA,CAAC;AACyB;AAC1B,4C;;;;;;;;AC9CA;AAAA;AAAA;AAAA;AAAA;AACA;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;AACA;AACA,aAAa,6BAA6B,0BAA0B,aAAa,EAAE,qBAAqB;AACxG,gBAAgB,qDAAqD,oEAAoE,aAAa,EAAE;AACxJ,sBAAsB,sBAAsB,qBAAqB,GAAG;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,kCAAkC,SAAS;AAC3C,kCAAkC,WAAW,UAAU;AACvD,yCAAyC,cAAc;AACvD;AACA,6GAA6G,OAAO,UAAU;AAC9H,gFAAgF,iBAAiB,OAAO;AACxG,wDAAwD,gBAAgB,QAAQ,OAAO;AACvF,8CAA8C,gBAAgB,gBAAgB,OAAO;AACrF;AACA,iCAAiC;AACjC;AACA;AACA,SAAS,YAAY,aAAa,OAAO,EAAE,UAAU,WAAW;AAChE,mCAAmC,SAAS;AAC5C;AACA;AACoI;AAC3F;AACuB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,6BAA6B,mEAAY;AACzC;AACA;AACA,kBAAkB;AAClB;AACA,0BAA0B,mEAAY;AACtC;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oFAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,uCAAuC,EAAE;AACtG,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA,6BAA6B,yDAAyD;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B,8BAA8B,QAAQ;AACtC;AACA;AACA;AACA,iCAAiC,gBAAgB;AACjD,kCAAkC,6DAA6D,EAAE;AACjG;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC,2BAA2B,OAAO;AAClC;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO,gEAAS;AACzB;AACA;AACA,mCAAmC,0EAAiB;AACpD,iBAAiB,IAAI;AACrB;AACA;AACA,qDAAqD;AACrD,SAAS,OAAO,iEAAU,GAAG;AAC7B,SAAS,OAAO,gEAAS,GAAG;AAC5B,SAAS,OAAO,+DAAQ,GAAG;AAC3B,SAAS,OAAO,6DAAM,GAAG;AACzB,MAAM;AACN;AACA,oBAAoB,OAAO,4DAAK,EAAE;AAClC,uBAAuB,OAAO,4DAAK,EAAE;AACrC,8BAA8B,OAAO,4DAAK,EAAE;AAC5C,uBAAuB,OAAO,6DAAM,EAAE;AACtC,oBAAoB,OAAO,6DAAM,EAAE;AACnC,uBAAuB,OAAO,iEAAS,wBAAwB;AAC/D;AACA;AACA,CAAC;AAC6B;AAC9B,gD;;;;;;;;AC/Pa;AACb,oBAAoB,mBAAO,CAAC,GAAe;AAC3C,uBAAuB,mBAAO,CAAC,GAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,WAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;;;;;;;AC9CmD;AACc;AACJ;AACjB;AAE5C;;;;;GAKG;AAOH;IAUE,qBAAmB,OAAsB,EAAS,SAAoB;QAAnD,YAAO,GAAP,OAAO,CAAe;QAAS,cAAS,GAAT,SAAS,CAAW;QAPtE,aAAQ,GAAY,IAAI,CAAC;QACzB,gBAAW,GAAG,mFAAe,CAAC;QAE9B,SAAI,GAAG,CAAC,EAAC,IAAI,EAAE,IAAI,EAAE,GAAG,EAAE,KAAK,EAAC,CAAC,CAAC;QAKhC,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QAC/B,6CAAgB,EAAhB,qCAAgB,CAAkC;QACvD,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;IACnB,CAAC;IAED,oCAAc,GAAd;QACE,OAAO,CAAC,GAAG,CAAC,4BAA4B,CAAC,CAAC;QAC1C,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,EAAE,CAAC,CAAC;QAClC,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,IAAI,CAAC,SAAS,CAAC,eAAe,EAAE,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IAC1E,CAAC;IAbkB;QAAlB,yEAAS,CAAC,6DAAM,CAAC;kCAAS,6DAAM;+CAAC;IACZ;QAArB,yEAAS,CAAC,oEAAS,CAAC;kCAAY,oEAAS;kDAAC;IARhC,WAAW;QAJvB,wEAAS,CAAC;YACT,QAAQ,EAAE,cAAc;WACG;SAC5B,CAAC;oBAWsE;OAV3D,WAAW,CAsBvB;IAAD,CAAC;AAAA;SAtBY,WAAW,e;;;;;;;;ACjBX;AACb,mBAAmB,mBAAO,CAAC,EAAkB;AAC7C,kBAAkB,mBAAO,CAAC,GAA4B;AACtD;AACA,qC;;;;;;;;ACJa;AACb,mBAAmB,mBAAO,CAAC,EAAkB;AAC7C,cAAc,mBAAO,CAAC,GAAwB;AAC9C;AACA,iC;;;;;;;;ACJa;AACb,mBAAmB,mBAAO,CAAC,EAAkB;AAC7C,qBAAqB,mBAAO,CAAC,GAA6B;AAC1D;AACA,wC;;;;;;;;ACJa;AACb,cAAc,mBAAO,CAAC,GAAoB;AAC1C,qBAAqB,mBAAO,CAAC,GAA2B;AACxD;AACA;AACA;AACA;AACA,qCAAqC,YAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,iBAAiB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA,WAAW,UAAU,wBAAwB,iBAAiB;AAC9D;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA,wC;;;;;;;;ACtDa;AACb;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA,aAAa,mBAAO,CAAC,EAAc;AACnC,eAAe,mBAAO,CAAC,GAAU;AACjC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,uC;;;;;;;;AC7Ia;AACb;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA,qBAAqB,mBAAO,CAAC,EAAiB;AAC9C;AACA,uCAAuC,gBAAgB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB;AAChB;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA,CAAC;AACD;AACA,kC;;;;;;;;AC3Ca;AACb;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA,kBAAkB,mBAAO,CAAC,GAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,kCAAkC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,0C;;;;;;;;AClDa;AACb;AACA;AACA;AACA;AACA;AACA,kDAAkD,aAAa;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qBAAqB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mCAAmC;AAClD;AACA,eAAe,OAAO;AACtB;AACA,eAAe,EAAE;AACjB;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA,uDAAuD,oBAAoB;AAC3E;AACA,CAAC;AACD;AACA,qC;;;;;;;;AChDa;AACb;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA,mBAAmB,mBAAO,CAAC,EAAe;AAC1C,cAAc,mBAAO,CAAC,GAAoB;AAC1C;AACA;AACA;AACA;AACA,qCAAqC,YAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,iBAAiB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA,WAAW,UAAU,wBAAwB,iBAAiB;AAC9D;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D,8BAA8B,kEAAkE;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,wC;;;;;;;;ACnHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAyC;AACG;AACM;AACE;AACoB;AACL;AACI;AACR;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6FAAmB;AACnC;AACA;AACA;AACA;AACA,SAAS,OAAO,+DAAQ;AACxB;AACA,wBAAwB,uEAAQ;AAChC,wBAAwB,yEAAS;AACjC,wBAAwB,wFAAgB;AACxC,wBAAwB,4FAAkB;AAC1C,wBAAwB,oFAAc;AACtC;AACA;AACA,wBAAwB,kEAAW;AACnC;AACA;AACA,wBAAwB,uEAAQ;AAChC,wBAAwB,yEAAS;AACjC;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,kDAAkD,WAAW;AAC7D;AACA,CAAC;AAC0B;AAC3B,6C","file":"0.js","sourcesContent":["import {NgModule} from '@angular/core';\nimport {IonicPageModule} from 'ionic-angular';\nimport {ProductPage} from './product';\nimport {SuperTabsModule} from \"ionic2-super-tabs\";\n\n@NgModule({\n  declarations: [\n    ProductPage,\n  ],\n  imports: [\n    IonicPageModule.forChild(ProductPage),\n    SuperTabsModule.forRoot(),\n  ]\n})\nexport class ProductPageModule {\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/pages/product/product.module.ts","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [0, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { Component, ElementRef, EventEmitter, forwardRef, Input, Optional, Output, Renderer2, ViewChild, ViewEncapsulation } from '@angular/core';\nimport { App, DeepLinker, DomController, NavController, Platform, RootNode, ViewController } from 'ionic-angular';\nimport { Observable } from 'rxjs/Observable';\nimport { SuperTabsToolbar } from './super-tabs-toolbar';\nimport { SuperTabsContainer } from './super-tabs-container';\nimport { SuperTabsController } from '../providers/super-tabs-controller';\nimport { DIRECTION_SWITCH } from 'ionic-angular/navigation/nav-util';\nimport 'rxjs/add/observable/fromEvent';\nimport 'rxjs/add/observable/merge';\nimport 'rxjs/add/operator/debounceTime';\nvar SuperTabs = (function () {\n    function SuperTabs(parent, viewCtrl, _app, el, rnd, superTabsCtrl, linker, domCtrl, _plt) {\n        var _this = this;\n        this.viewCtrl = viewCtrl;\n        this._app = _app;\n        this.el = el;\n        this.rnd = rnd;\n        this.superTabsCtrl = superTabsCtrl;\n        this.linker = linker;\n        this.domCtrl = domCtrl;\n        this._plt = _plt;\n        /**\n         * Color of the slider that moves based on what tab is selected\n         */\n        this.indicatorColor = 'primary';\n        /**\n         * Badge color\n         */\n        this.badgeColor = 'primary';\n        /**\n         * Configuration\n         */\n        this.config = {};\n        /**\n         * Tab buttons placement. Can be `top` or `bottom`.\n         * @type {string}\n         */\n        this.tabsPlacement = 'top';\n        /**\n         * Emits the tab index when the selected tab changes\n         * @type {EventEmitter<Object>}\n         */\n        this.tabSelect = new EventEmitter();\n        /**\n         * Indicates whether the toolbar is visible\n         * @private\n         */\n        this._isToolbarVisible = true;\n        /**\n         * @private\n         */\n        this._tabs = [];\n        /**\n         * Indicates whether the tab buttons should scroll\n         * @type {boolean}\n         * @private\n         */\n        this._scrollTabs = false;\n        /**\n         * Selected tab index\n         * @type {number}\n         * @private\n         */\n        this._selectedTabIndex = 0;\n        /**\n         * Any observable subscriptions that we should unsubscribe from when destroying this component\n         * @type {Array<Subscription>}\n         * @private\n         */\n        this.watches = [];\n        /**\n         * Indicates whether any of the tabs has an icon\n         * @type {boolean}\n         * @private\n         */\n        this.hasIcons = false;\n        /**\n         * Indicates whether any of the tabs has a title\n         * @type {boolean}\n         * @private\n         */\n        this.hasTitles = false;\n        /**\n         * Indicates whether the component has finished initializing\n         * @type {boolean}\n         * @private\n         */\n        this.init = false;\n        this.parent = parent;\n        if (this.parent) {\n            this.parent.registerChildNav(this);\n        }\n        else if (viewCtrl && viewCtrl.getNav()) {\n            this.parent = viewCtrl.getNav();\n            this.parent.registerChildNav(this);\n        }\n        else if (this._app) {\n            this._app.registerRootNav(this);\n        }\n        var obsToMerge = [\n            Observable.fromEvent(window, 'orientationchange'),\n            Observable.fromEvent(window, 'resize')\n        ];\n        if (viewCtrl) {\n            obsToMerge.push(viewCtrl.didEnter);\n        }\n        // re-adjust the height of the slider when the orientation changes\n        var $windowResize = Observable.merge.apply(this, obsToMerge).debounceTime(100);\n        var windowResizeSub = $windowResize.subscribe(function () {\n            _this.resize();\n        });\n        this.watches.push(windowResizeSub);\n    }\n    Object.defineProperty(SuperTabs.prototype, \"height\", {\n        get: function () {\n            return this.el.nativeElement.offsetHeight;\n        },\n        /**\n         * Height of the tabs\n         */\n        set: function (val) {\n            this.rnd.setStyle(this.el.nativeElement, 'height', val + 'px');\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SuperTabs.prototype, \"selectedTabIndex\", {\n        get: function () {\n            return this._selectedTabIndex;\n        },\n        /**\n         * The initial selected tab index\n         * @param val {number} tab index\n         */\n        set: function (val) {\n            this._selectedTabIndex = Number(val);\n            this.init && this.alignIndicatorPosition(true);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SuperTabs.prototype, \"scrollTabs\", {\n        get: function () {\n            return this._scrollTabs;\n        },\n        /**\n         * Set to true to enable tab buttons scrolling\n         * @param val\n         */\n        set: function (val) {\n            this._scrollTabs = typeof val !== 'boolean' || val === true;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SuperTabs.prototype.ngOnInit = function () {\n        var defaultConfig = {\n            dragThreshold: 10,\n            allowElementScroll: false,\n            maxDragAngle: 40,\n            sideMenuThreshold: 50,\n            transitionDuration: 300,\n            transitionEase: 'cubic-bezier(0.35, 0, 0.25, 1)',\n            shortSwipeDuration: 300\n        };\n        for (var prop in this.config) {\n            defaultConfig[prop] = this.config[prop];\n        }\n        this.config = defaultConfig;\n        if (this.config.allowElementScroll === true) {\n            if (this.config.dragThreshold < 110) {\n                this.config.dragThreshold = 110;\n            }\n        }\n        this.id = this.id || \"super-tabs-\" + ++superTabsIds;\n        this.superTabsCtrl.registerInstance(this);\n        if (this.tabsPlacement === 'bottom') {\n            this.rnd.addClass(this.getElementRef().nativeElement, 'tabs-placement-bottom');\n        }\n    };\n    SuperTabs.prototype.ngAfterContentInit = function () {\n        this.updateTabWidth();\n        this.toolbar.tabs = this._tabs;\n    };\n    SuperTabs.prototype.ngAfterViewInit = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            var tabsSegment;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        tabsSegment = this.linker.getSegmentByNavIdOrName(this.id, this.name);\n                        if (tabsSegment) {\n                            this.selectedTabIndex = this.getTabIndexById(tabsSegment.id);\n                        }\n                        this.linker.navChange(DIRECTION_SWITCH);\n                        if (!this.hasTitles && !this.hasIcons)\n                            this._isToolbarVisible = false;\n                        this.tabsContainer.slideTo(this.selectedTabIndex, false);\n                        return [4 /*yield*/, this.refreshTabStates()];\n                    case 1:\n                        _a.sent();\n                        this.fireLifecycleEvent(['willEnter', 'didEnter']);\n                        this.setFixedIndicatorWidth();\n                        // we need this to make sure the \"slide\" thingy doesn't move outside the screen\n                        this.setMaxIndicatorPosition();\n                        setTimeout(function () { return _this.alignIndicatorPosition(); }, 100);\n                        this.refreshContainerHeight();\n                        this.init = true;\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    SuperTabs.prototype.ngOnDestroy = function () {\n        this.watches.forEach(function (watch) {\n            watch.unsubscribe && watch.unsubscribe();\n        });\n        this.parent.unregisterChildNav(this);\n        this.superTabsCtrl.unregisterInstance(this.id);\n    };\n    SuperTabs.prototype.getType = function () {\n        return;\n    };\n    SuperTabs.prototype.getSecondaryIdentifier = function () {\n        return;\n    };\n    SuperTabs.prototype.getAllChildNavs = function () {\n        return this._tabs;\n    };\n    SuperTabs.prototype.resize = function () {\n        if (this.el.nativeElement.offsetParent === null)\n            return;\n        this.setMaxIndicatorPosition();\n        this.updateTabWidth();\n        this.setFixedIndicatorWidth();\n        this.refreshTabWidths();\n        this.tabsContainer.refreshDimensions();\n        this.tabsContainer.slideTo(this.selectedTabIndex);\n        this.alignIndicatorPosition();\n        this.refreshContainerHeight();\n    };\n    /**\n     * Sets the badge number for a specific tab\n     * @param tabId {string} tab ID\n     * @param value {number} badge number\n     */\n    SuperTabs.prototype.setBadge = function (tabId, value) {\n        this.getTabById(tabId).setBadge(value);\n    };\n    /**\n     * Clears the badge for a specific tab\n     * @param tabId {string} tab ID\n     */\n    SuperTabs.prototype.clearBadge = function (tabId) {\n        this.getTabById(tabId).clearBadge();\n    };\n    /**\n     * Increases the badge value for a specific tab\n     * @param tabId {string} tab ID\n     * @param increaseBy {number} the number to increase by\n     */\n    SuperTabs.prototype.increaseBadge = function (tabId, increaseBy) {\n        this.getTabById(tabId).increaseBadge(increaseBy);\n    };\n    SuperTabs.prototype.decreaseBadge = function (tabId, decreaseBy) {\n        this.getTabById(tabId).decreaseBadge(decreaseBy);\n    };\n    SuperTabs.prototype.enableTabsSwipe = function (enable) {\n        this.tabsContainer.enableTabsSwipe(enable);\n    };\n    SuperTabs.prototype.enableTabSwipe = function (tabId, enable) {\n        this.tabsContainer.enableTabSwipe(this.getTabIndexById(tabId), enable);\n    };\n    SuperTabs.prototype.showToolbar = function (show) {\n        this._isToolbarVisible = show;\n        this.refreshContainerHeight();\n    };\n    SuperTabs.prototype.slideTo = function (indexOrId, fireEvent) {\n        if (fireEvent === void 0) { fireEvent = true; }\n        typeof indexOrId === 'string' && (indexOrId = this.getTabIndexById(indexOrId));\n        fireEvent && this.onToolbarTabSelect(indexOrId);\n    };\n    SuperTabs.prototype.getActiveChildNavs = function () {\n        if (this.selectedTabIndex < 0) {\n            this.selectedTabIndex = 0;\n        }\n        return [this._tabs[this.selectedTabIndex]];\n    };\n    SuperTabs.prototype.addTab = function (tab) {\n        tab.rootNavCtrl = this.parent;\n        tab.rootParams = tab.rootParams || {};\n        tab.tabId = tab.tabId || \"super-tabs-\" + this.id + \"-tab-\" + this._tabs.length;\n        this._tabs.push(tab);\n        if (tab.icon) {\n            this.hasIcons = true;\n        }\n        if (tab.title) {\n            this.hasTitles = true;\n        }\n        tab.setWidth(this.el.nativeElement.offsetWidth);\n    };\n    /**\n     * We listen to drag events to move the \"slide\" thingy along with the slides\n     */\n    SuperTabs.prototype.onDrag = function () {\n        var _this = this;\n        if (!this._isToolbarVisible)\n            return;\n        this.domCtrl.write(function () {\n            var singleSlideWidth = _this.tabsContainer.tabWidth, slidesWidth = _this.tabsContainer.containerWidth;\n            var percentage = Math.abs(_this.tabsContainer.containerPosition / slidesWidth);\n            if (_this.scrollTabs) {\n                var originalSlideStart = singleSlideWidth * _this.selectedTabIndex, originalPosition = _this.getRelativeIndicatorPosition(), originalWidth = _this.getSegmentButtonWidth();\n                var nextPosition = void 0, nextWidth = void 0, indicatorPosition = void 0, indicatorWidth = void 0;\n                var deltaTabPos = originalSlideStart - Math.abs(_this.tabsContainer.containerPosition);\n                percentage = Math.abs(deltaTabPos / singleSlideWidth);\n                if (deltaTabPos < 0) {\n                    // going to next slide\n                    nextPosition = _this.getRelativeIndicatorPosition(_this.selectedTabIndex + 1);\n                    nextWidth = _this.getSegmentButtonWidth(_this.selectedTabIndex + 1);\n                    indicatorPosition = originalPosition + percentage * (nextPosition - originalPosition);\n                }\n                else {\n                    // going to previous slide\n                    nextPosition = _this.getRelativeIndicatorPosition(_this.selectedTabIndex - 1);\n                    nextWidth = _this.getSegmentButtonWidth(_this.selectedTabIndex - 1);\n                    indicatorPosition = originalPosition - percentage * (originalPosition - nextPosition);\n                }\n                var deltaWidth = nextWidth - originalWidth;\n                indicatorWidth = originalWidth + percentage * deltaWidth;\n                if ((originalWidth > nextWidth && indicatorWidth < nextWidth) || (originalWidth < nextWidth && indicatorWidth > nextWidth)) {\n                    // this is only useful on desktop, because you are able to drag and swipe through multiple tabs at once\n                    // which results in the indicator width to be super small/big since it's changing based on the current/next widths\n                    indicatorWidth = nextWidth;\n                }\n                _this.alignTabButtonsContainer();\n                _this.toolbar.setIndicatorProperties(indicatorWidth, indicatorPosition);\n            }\n            else {\n                _this.toolbar.setIndicatorPosition(Math.min(percentage * singleSlideWidth, _this.maxIndicatorPosition));\n            }\n        });\n    };\n    /**\n     * Runs when the user clicks on a segment button\n     * @param index\n     */\n    SuperTabs.prototype.onTabChange = function (index) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        index = Number(index);\n                        if (index === this.selectedTabIndex) {\n                            this.tabSelect.emit({\n                                index: index,\n                                id: this._tabs[index].tabId,\n                                changed: false\n                            });\n                            return [2 /*return*/];\n                        }\n                        if (!(index <= this._tabs.length)) return [3 /*break*/, 2];\n                        this.fireLifecycleEvent(['willLeave', 'didLeave']);\n                        this.selectedTabIndex = index;\n                        this.linker.navChange(DIRECTION_SWITCH);\n                        return [4 /*yield*/, this.refreshTabStates()];\n                    case 1:\n                        _a.sent();\n                        this.fireLifecycleEvent(['willEnter', 'didEnter']);\n                        this.tabSelect.emit({\n                            index: index,\n                            id: this._tabs[index].tabId,\n                            changed: true\n                        });\n                        _a.label = 2;\n                    case 2: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    SuperTabs.prototype.onToolbarTabSelect = function (index) {\n        if (index !== this.selectedTabIndex) {\n            this.tabsContainer.slideTo(index);\n        }\n        return this.onTabChange(index);\n    };\n    SuperTabs.prototype.onContainerTabSelect = function (ev) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!ev.changed) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.onTabChange(ev.index)];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2:\n                        this.alignIndicatorPosition(true);\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    SuperTabs.prototype.fireLifecycleEvent = function (events) {\n        var activeView = this.getActiveTab().getActive();\n        events.forEach(function (event) {\n            switch (event) {\n                case 'willEnter':\n                    activeView._willEnter();\n                    break;\n                case 'didEnter':\n                    activeView._didEnter();\n                    break;\n                case 'willLeave':\n                    activeView._willLeave(false);\n                    break;\n                case 'didLeave':\n                    activeView._didLeave();\n                    break;\n            }\n        });\n    };\n    SuperTabs.prototype.refreshTabStates = function () {\n        var _this = this;\n        return Promise.all(this._tabs.map(function (tab, i) {\n            tab.setActive(i === _this.selectedTabIndex);\n            return tab.load(Math.abs(_this.selectedTabIndex - i) < 2);\n        }));\n    };\n    SuperTabs.prototype.updateTabWidth = function () {\n        this.tabsContainer.tabWidth = this.el.nativeElement.offsetWidth;\n    };\n    SuperTabs.prototype.refreshContainerHeight = function () {\n        var heightOffset = 0;\n        if (this._isToolbarVisible) {\n            if (this.hasTitles && this.hasIcons) {\n                heightOffset = 72;\n            }\n            else if (this.hasTitles || this.hasIcons) {\n                heightOffset = 48;\n            }\n        }\n        this.rnd.setStyle(this.tabsContainer.getNativeElement(), 'height', \"calc(100% - \" + heightOffset + \"px)\");\n    };\n    SuperTabs.prototype.refreshTabWidths = function () {\n        var width = this.el.nativeElement.offsetWidth;\n        this._tabs.forEach(function (tab) { return tab.setWidth(width); });\n    };\n    SuperTabs.prototype.alignTabButtonsContainer = function (animate) {\n        var mw = this.el.nativeElement.offsetWidth, // max width\n        iw = this.toolbar.indicatorWidth, // indicator width\n        ip = this.toolbar.indicatorPosition, // indicatorPosition\n        sp = this.toolbar.segmentPosition; // segment position\n        if (mw === 0)\n            return;\n        if (this.toolbar.segmentWidth <= mw) {\n            if (this.toolbar.segmentPosition !== 0) {\n                this.toolbar.setSegmentPosition(0, animate);\n            }\n            return;\n        }\n        var pos;\n        if (ip + iw + (mw / 2 - iw / 2) > mw + sp) {\n            // we need to move the segment container to the left\n            var delta = (ip + iw + (mw / 2 - iw / 2)) - mw - sp, max = this.toolbar.segmentWidth - mw;\n            pos = sp + delta;\n            pos = pos < max ? pos : max;\n        }\n        else if (ip - (mw / 2 - iw / 2) < sp) {\n            // we need to move the segment container to the right\n            pos = ip - (mw / 2 - iw / 2);\n            // pos = pos >= 0? pos : 0;\n            pos = pos < 0 ? 0 : pos > ip ? (ip - mw + iw) : pos;\n            // pos = pos < 0? 0 : pos > maxPos? maxPos : pos;\n        }\n        else\n            return; // no need to move the segment container\n        this.toolbar.setSegmentPosition(pos, animate);\n    };\n    SuperTabs.prototype.getRelativeIndicatorPosition = function (index) {\n        if (index === void 0) { index = this.selectedTabIndex; }\n        var position = 0;\n        for (var i = 0; i < this.toolbar.segmentButtonWidths.length; i++) {\n            if (index > Number(i)) {\n                position += this.toolbar.segmentButtonWidths[i];\n            }\n        }\n        return position;\n    };\n    SuperTabs.prototype.getAbsoluteIndicatorPosition = function () {\n        var position = this.selectedTabIndex * this.tabsContainer.tabWidth / this._tabs.length;\n        return position <= this.maxIndicatorPosition ? position : this.maxIndicatorPosition;\n    };\n    /**\n     * Gets the width of a tab button when `scrollTabs` is set to `true`\n     */\n    SuperTabs.prototype.getSegmentButtonWidth = function (index) {\n        if (index === void 0) { index = this.selectedTabIndex; }\n        if (!this._isToolbarVisible)\n            return;\n        return this.toolbar.segmentButtonWidths[index];\n    };\n    SuperTabs.prototype.setMaxIndicatorPosition = function () {\n        if (this.el && this.el.nativeElement) {\n            this.maxIndicatorPosition = this.el.nativeElement.offsetWidth - (this.el.nativeElement.offsetWidth / this._tabs.length);\n        }\n    };\n    SuperTabs.prototype.setFixedIndicatorWidth = function () {\n        if (this.scrollTabs || !this._isToolbarVisible)\n            return;\n        // the width of the \"slide\", should be equal to the width of a single `ion-segment-button`\n        // we'll just calculate it instead of querying for a segment button\n        this.toolbar.setIndicatorWidth(this.el.nativeElement.offsetWidth / this._tabs.length, false);\n    };\n    /**\n     * Aligns slide position with selected tab\n     */\n    SuperTabs.prototype.alignIndicatorPosition = function (animate) {\n        if (animate === void 0) { animate = false; }\n        if (!this._isToolbarVisible)\n            return;\n        if (this.scrollTabs) {\n            this.toolbar.alignIndicator(this.getRelativeIndicatorPosition(), this.getSegmentButtonWidth(), animate);\n            this.alignTabButtonsContainer(animate);\n        }\n        else {\n            this.toolbar.setIndicatorPosition(this.getAbsoluteIndicatorPosition(), animate);\n        }\n    };\n    SuperTabs.prototype.getTabIndexById = function (tabId) {\n        return this._tabs.findIndex(function (tab) { return tab.tabId === tabId; });\n    };\n    SuperTabs.prototype.getTabById = function (tabId) {\n        return this._tabs.find(function (tab) { return tab.tabId === tabId; });\n    };\n    SuperTabs.prototype.getActiveTab = function () {\n        return this._tabs[this.selectedTabIndex];\n    };\n    // needed since we're implementing RootNode\n    SuperTabs.prototype.getElementRef = function () {\n        return this.el;\n    };\n    // needed since we're implementing RootNode\n    SuperTabs.prototype.initPane = function () {\n        return true;\n    };\n    // needed since we're implementing RootNode\n    SuperTabs.prototype.paneChanged = function () {\n    };\n    // needed to make Ionic Framework think this is a tabs component... needed for Deeplinking\n    SuperTabs.prototype.getSelected = function () {\n    };\n    // needed to make Ionic Framework think this is a tabs component... needed for Deeplinking\n    SuperTabs.prototype.setTabbarPosition = function () {\n    };\n    // update segment button widths manually\n    SuperTabs.prototype.indexSegmentButtonWidths = function () {\n        var _this = this;\n        this._plt.raf(function () { return _this.toolbar.indexSegmentButtonWidths(); });\n    };\n    SuperTabs.decorators = [\n        { type: Component, args: [{\n                    selector: 'super-tabs',\n                    template: \"\\n    <super-tabs-toolbar [tabsPlacement]=\\\"tabsPlacement\\\" [hidden]=\\\"!_isToolbarVisible\\\" [config]=\\\"config\\\"\\n                        [color]=\\\"toolbarBackground\\\"\\n                        [tabsColor]=\\\"toolbarColor\\\" [indicatorColor]=\\\"indicatorColor\\\" [badgeColor]=\\\"badgeColor\\\"\\n                        [scrollTabs]=\\\"scrollTabs\\\"\\n                        [selectedTab]=\\\"selectedTabIndex\\\"\\n                        (tabSelect)=\\\"onToolbarTabSelect($event)\\\"></super-tabs-toolbar>\\n    <super-tabs-container [config]=\\\"config\\\" [tabsCount]=\\\"_tabs.length\\\" [selectedTabIndex]=\\\"selectedTabIndex\\\"\\n                          (tabSelect)=\\\"onContainerTabSelect($event)\\\" (onDrag)=\\\"onDrag()\\\">\\n      <ng-content></ng-content>\\n    </super-tabs-container>\\n  \",\n                    encapsulation: ViewEncapsulation.None,\n                    providers: [\n                        {\n                            provide: RootNode,\n                            useExisting: forwardRef(function () { return SuperTabs; })\n                        }\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    SuperTabs.ctorParameters = function () { return [\n        { type: NavController, decorators: [{ type: Optional },] },\n        { type: ViewController, decorators: [{ type: Optional },] },\n        { type: App, },\n        { type: ElementRef, },\n        { type: Renderer2, },\n        { type: SuperTabsController, },\n        { type: DeepLinker, },\n        { type: DomController, },\n        { type: Platform, },\n    ]; };\n    SuperTabs.propDecorators = {\n        'toolbarBackground': [{ type: Input },],\n        'toolbarColor': [{ type: Input },],\n        'indicatorColor': [{ type: Input },],\n        'badgeColor': [{ type: Input },],\n        'config': [{ type: Input },],\n        'id': [{ type: Input },],\n        'name': [{ type: Input },],\n        'height': [{ type: Input },],\n        'selectedTabIndex': [{ type: Input },],\n        'scrollTabs': [{ type: Input },],\n        'tabsPlacement': [{ type: Input },],\n        'tabSelect': [{ type: Output },],\n        'toolbar': [{ type: ViewChild, args: [SuperTabsToolbar,] },],\n        'tabsContainer': [{ type: ViewChild, args: [SuperTabsContainer,] },],\n    };\n    return SuperTabs;\n}());\nexport { SuperTabs };\nvar superTabsIds = -1;\n//# sourceMappingURL=super-tabs.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ionic2-super-tabs/dist/components/super-tabs.js\n// module id = 284\n// module chunks = 0","import { Injectable } from '@angular/core';\nvar SuperTabsController = (function () {\n    function SuperTabsController() {\n        this.instances = [];\n    }\n    SuperTabsController.prototype.setBadge = function (tabId, value, tabsId) {\n        var instance = this.getInstance(tabsId);\n        instance && instance.setBadge(tabId, value);\n    };\n    SuperTabsController.prototype.clearBadge = function (tabId, tabsId) {\n        var instance = this.getInstance(tabsId);\n        instance && instance.clearBadge(tabId);\n    };\n    SuperTabsController.prototype.increaseBadge = function (tabId, increaseBy, tabsId) {\n        if (increaseBy === void 0) { increaseBy = 1; }\n        var instance = this.getInstance(tabsId);\n        instance && instance.increaseBadge(tabId, increaseBy);\n    };\n    SuperTabsController.prototype.decreaseBadge = function (tabId, decreaseBy, tabsId) {\n        if (decreaseBy === void 0) { decreaseBy = 1; }\n        var instance = this.getInstance(tabsId);\n        instance && instance.decreaseBadge(tabId, decreaseBy);\n    };\n    /**\n     * Enables/disables swiping on a specific tabs instance\n     * @param enable\n     * @param [tabsId]\n     */\n    SuperTabsController.prototype.enableTabsSwipe = function (enable, tabsId) {\n        var instance = this.getInstance(tabsId);\n        instance && instance.enableTabsSwipe(enable);\n    };\n    /**\n     * Enables/disables swiping when this tab is active\n     * @param tabId\n     * @param enable\n     * @param [tabsId]\n     */\n    SuperTabsController.prototype.enableTabSwipe = function (tabId, enable, tabsId) {\n        var instance = this.getInstance(tabsId);\n        instance && instance.enableTabSwipe(tabId, enable);\n    };\n    SuperTabsController.prototype.showToolbar = function (show, tabsId) {\n        var instance = this.getInstance(tabsId);\n        instance && instance.showToolbar(show);\n    };\n    SuperTabsController.prototype.slideTo = function (tabIndexOrId, tabsId) {\n        var instance = this.getInstance(tabsId);\n        instance && instance.slideTo(tabIndexOrId);\n    };\n    /**\n     * @private\n     */\n    SuperTabsController.prototype.registerInstance = function (instance) {\n        this.instances.push(instance);\n    };\n    /**\n     * @private\n     */\n    SuperTabsController.prototype.unregisterInstance = function (id) {\n        var instanceIndex = this.getInstanceIndex(id);\n        if (instanceIndex > -1)\n            this.instances.splice(instanceIndex, 1);\n    };\n    SuperTabsController.prototype.getInstanceIndex = function (id) {\n        return this.instances.findIndex(function (instance) { return instance.id === id; });\n    };\n    SuperTabsController.prototype.getInstance = function (id) {\n        return (!!id && this.instances[this.getInstanceIndex(id)]) || this.instances[0];\n    };\n    SuperTabsController.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    SuperTabsController.ctorParameters = function () { return []; };\n    return SuperTabsController;\n}());\nexport { SuperTabsController };\n//# sourceMappingURL=super-tabs-controller.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ionic2-super-tabs/dist/providers/super-tabs-controller.js\n// module id = 285\n// module chunks = 0","export * from './components/super-tab';\nexport * from './components/super-tabs';\nexport * from './providers/super-tabs-controller';\nexport * from './super-tabs.module';\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ionic2-super-tabs/dist/index.js\n// module id = 286\n// module chunks = 0","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [0, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { ChangeDetectorRef, Component, ComponentFactoryResolver, ElementRef, ErrorHandler, Input, NgZone, Optional, Renderer, ViewChild, ViewContainerRef, ViewEncapsulation } from '@angular/core';\nimport { App, Config, DeepLinker, DomController, GestureController, NavControllerBase, Platform } from 'ionic-angular';\nimport { TransitionController } from 'ionic-angular/transitions/transition-controller';\nimport { SuperTabs } from './super-tabs';\nvar SuperTab = (function (_super) {\n    __extends(SuperTab, _super);\n    function SuperTab(parent, app, config, plt, el, zone, rnd, cfr, gestureCtrl, transCtrl, errorHandler, linker, _dom, cd) {\n        var _this = _super.call(this, parent, app, config, plt, el, zone, rnd, cfr, gestureCtrl, transCtrl, linker, _dom, errorHandler) || this;\n        _this.linker = linker;\n        _this._dom = _dom;\n        _this.cd = cd;\n        /**\n         * Indicates whether the tab has been loaded\n         * @type {boolean}\n         */\n        _this.loaded = false;\n        _this.init = new Promise(function (resolve) { return _this.initResolve = resolve; });\n        return _this;\n    }\n    Object.defineProperty(SuperTab.prototype, \"tabTitle\", {\n        // TODO find less hacky approach\n        // needed to make Ionic Framework think this is a tabs component... needed for Deeplinking\n        get: function () {\n            return this.title;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SuperTab.prototype, \"index\", {\n        // needed to make Ionic Framework think this is a tabs component... needed for Deeplinking\n        get: function () {\n            return this.parent.getTabIndexById(this.tabId);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SuperTab.prototype, \"rootParams\", {\n        get: function () {\n            return this._rootParams;\n        },\n        /**\n         * @input {object} Any nav-params to pass to the root page of this tab.\n         */\n        set: function (params) {\n            params.rootNavCtrl = this.rootNavCtrl;\n            this._rootParams = params;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SuperTab.prototype, \"_tabId\", {\n        get: function () {\n            return this.tabId;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SuperTab.prototype, \"swipeBackEnabled\", {\n        /**\n         * Enable/disable swipe to go back for iOS\n         * @return {boolean}\n         */\n        get: function () {\n            return this._sbEnabled;\n        },\n        set: function (val) {\n            this._sbEnabled = Boolean(val);\n            this._swipeBackCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SuperTab.prototype, \"_vp\", {\n        /**\n         * @hidden\n         */\n        set: function (val) {\n            this.setViewport(val);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SuperTab.prototype._didEnter = function (view) {\n        if (this.loaded) {\n            _super.prototype._didEnter.call(this, view);\n        }\n    };\n    SuperTab.prototype._willEnter = function (view) {\n        if (this.loaded) {\n            _super.prototype._willEnter.call(this, view);\n        }\n    };\n    SuperTab.prototype.ngOnInit = function () {\n        this.parent.addTab(this);\n    };\n    SuperTab.prototype.ngAfterViewInit = function () {\n        this.initResolve();\n    };\n    SuperTab.prototype.ngOnDestroy = function () {\n        this.destroy();\n    };\n    SuperTab.prototype.setActive = function (active) {\n        if (active) {\n            this.cd.reattach();\n            this.cd.detectChanges();\n        }\n        else if (!active) {\n            this.cd.detach();\n        }\n    };\n    SuperTab.prototype.load = function (load) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(load && !this.loaded)) return [3 /*break*/, 3];\n                        return [4 /*yield*/, this.init];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, this.setRoot(this.root, this.rootParams, { animate: false })];\n                    case 2:\n                        _a.sent();\n                        this.loaded = true;\n                        _a.label = 3;\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    SuperTab.prototype.setBadge = function (value) {\n        this.badge = value;\n    };\n    SuperTab.prototype.clearBadge = function () {\n        delete this.badge;\n    };\n    SuperTab.prototype.increaseBadge = function (increaseBy) {\n        if (increaseBy === void 0) { increaseBy = 1; }\n        this.badge += increaseBy;\n    };\n    SuperTab.prototype.decreaseBadge = function (decreaseBy) {\n        if (decreaseBy === void 0) { decreaseBy = 1; }\n        this.badge = Math.max(0, this.badge - decreaseBy);\n    };\n    SuperTab.prototype.setWidth = function (width) {\n        this.setElementStyle('width', width + 'px');\n    };\n    SuperTab.prototype.goToRoot = function (opts) {\n        return this.setRoot(this.root, this.rootParams, opts, null);\n    };\n    SuperTab.decorators = [\n        { type: Component, args: [{\n                    selector: 'super-tab',\n                    template: '<div #viewport></div><div class=\"nav-decor\"></div>',\n                    encapsulation: ViewEncapsulation.None\n                },] },\n    ];\n    /** @nocollapse */\n    SuperTab.ctorParameters = function () { return [\n        { type: SuperTabs, },\n        { type: App, },\n        { type: Config, },\n        { type: Platform, },\n        { type: ElementRef, },\n        { type: NgZone, },\n        { type: Renderer, },\n        { type: ComponentFactoryResolver, },\n        { type: GestureController, },\n        { type: TransitionController, },\n        { type: ErrorHandler, },\n        { type: DeepLinker, decorators: [{ type: Optional },] },\n        { type: DomController, },\n        { type: ChangeDetectorRef, },\n    ]; };\n    SuperTab.propDecorators = {\n        'title': [{ type: Input },],\n        'icon': [{ type: Input },],\n        'root': [{ type: Input },],\n        'rootParams': [{ type: Input },],\n        'tabId': [{ type: Input, args: ['id',] },],\n        'badge': [{ type: Input },],\n        'swipeBackEnabled': [{ type: Input },],\n        '_vp': [{ type: ViewChild, args: ['viewport', { read: ViewContainerRef },] },],\n    };\n    return SuperTab;\n}(NavControllerBase));\nexport { SuperTab };\n//# sourceMappingURL=super-tab.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ionic2-super-tabs/dist/components/super-tab.js\n// module id = 287\n// module chunks = 0","import { Component, ElementRef, EventEmitter, Input, Output, Renderer2, ViewChild, ViewChildren, ViewEncapsulation } from '@angular/core';\nimport { DomController, Platform } from 'ionic-angular';\nimport { SuperTabsPanGesture } from '../super-tabs-pan-gesture';\nimport { SuperTabButton } from './super-tab-button';\nvar SuperTabsToolbar = (function () {\n    function SuperTabsToolbar(el, plt, rnd, domCtrl) {\n        this.el = el;\n        this.plt = plt;\n        this.rnd = rnd;\n        this.domCtrl = domCtrl;\n        this.color = '';\n        this.tabsColor = '';\n        this.badgeColor = '';\n        this.scrollTabs = false;\n        this.indicatorColor = '';\n        this.selectedTab = 0;\n        this.indicatorPosition = 0;\n        this.indicatorWidth = 0;\n        this.tabSelect = new EventEmitter();\n        /**\n         * @private\n         */\n        this.segmentPosition = 0;\n        /**\n         * The width of each button\n         */\n        this.segmentButtonWidths = [];\n        /**\n         * The segment width\n         */\n        this.segmentWidth = 0;\n        this.tabs = [];\n        this.animationState = {\n            indicator: false,\n            segment: false\n        };\n    }\n    SuperTabsToolbar.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        this.gesture = new SuperTabsPanGesture(this.plt, this.tabButtonsContainer.nativeElement, this.config, this.rnd);\n        this.gesture.onMove = function (delta) {\n            var newCPos = _this.segmentPosition + delta;\n            var mw = _this.el.nativeElement.offsetWidth, cw = _this.segmentWidth;\n            newCPos = Math.max(0, Math.min(newCPos, cw - mw));\n            _this.setSegmentPosition(newCPos);\n        };\n        if (this.scrollTabs) {\n            this.plt.timeout(function () {\n                _this.indexSegmentButtonWidths();\n            }, 10);\n        }\n    };\n    SuperTabsToolbar.prototype.ngOnDestroy = function () {\n        this.gesture && this.gesture.destroy();\n    };\n    SuperTabsToolbar.prototype.onTabSelect = function (index) {\n        this.tabSelect.emit(index);\n    };\n    SuperTabsToolbar.prototype.alignIndicator = function (position, width, animate) {\n        this.setIndicatorProperties(width, position, animate);\n    };\n    SuperTabsToolbar.prototype.setIndicatorPosition = function (position, animate) {\n        this.setIndicatorProperties(this.indicatorWidth, position, animate);\n    };\n    SuperTabsToolbar.prototype.setIndicatorWidth = function (width, animate) {\n        this.setIndicatorProperties(width, this.indicatorPosition, animate);\n    };\n    SuperTabsToolbar.prototype.setIndicatorProperties = function (width, position, animate) {\n        this.indicatorWidth = width;\n        this.indicatorPosition = position;\n        var scale = width / 100;\n        this.toggleAnimation('indicator', animate);\n        this.rnd.setStyle(this.indicator.nativeElement, this.plt.Css.transform, 'translate3d(' + (position - this.segmentPosition) + 'px, 0, 0) scale3d(' + scale + ', 1, 1)');\n    };\n    SuperTabsToolbar.prototype.setSegmentPosition = function (position, animate) {\n        this.segmentPosition = position;\n        this.toggleAnimation('segment', animate);\n        this.rnd.setStyle(this.tabButtonsBar.nativeElement, this.plt.Css.transform, \"translate3d(\" + -1 * position + \"px,0,0)\");\n        this.setIndicatorPosition(this.indicatorPosition, animate);\n    };\n    /**\n     * Enables/disables animation\n     * @param el\n     * @param animate\n     */\n    SuperTabsToolbar.prototype.toggleAnimation = function (el, animate) {\n        if (!this.config || this.config.transitionDuration === 0)\n            return;\n        // only change style if the value changed\n        if (this.animationState[el] === animate)\n            return;\n        this.animationState[el] = animate;\n        var _el = el === 'indicator' ? this.indicator.nativeElement : this.tabButtonsBar.nativeElement;\n        var value = animate ? \"all \" + this.config.transitionDuration + \"ms \" + this.config.transitionEase : 'initial';\n        this.rnd.setStyle(_el, this.plt.Css.transition, value);\n    };\n    /**\n     * Indexes the segment button widths\n     */\n    SuperTabsToolbar.prototype.indexSegmentButtonWidths = function () {\n        var index = [], total = 0;\n        this.tabButtons.forEach(function (btn, i) {\n            index[i] = btn.getNativeElement().offsetWidth;\n            total += index[i];\n        });\n        this.segmentButtonWidths = index;\n        this.segmentWidth = total;\n    };\n    SuperTabsToolbar.decorators = [\n        { type: Component, args: [{\n                    selector: 'super-tabs-toolbar',\n                    template: \"\\n    <ion-toolbar [color]=\\\"color\\\" mode=\\\"md\\\" [class.scroll-tabs]=\\\"scrollTabs\\\">\\n      <div class=\\\"tab-buttons-container\\\" #tabButtonsContainer>\\n        <div *ngIf=\\\"tabsPlacement === 'bottom'\\\" class=\\\"indicator {{ 'button-md-' + indicatorColor }}\\\" #indicator></div>\\n        <div class=\\\"tab-buttons\\\" #tabButtons>\\n          <super-tab-button *ngFor=\\\"let tab of tabs; let i = index\\\" (select)=\\\"onTabSelect(i)\\\" [title]=\\\"tab.title\\\"\\n                            [icon]=\\\"tab.icon\\\" [badge]=\\\"tab.badge\\\" [selected]=\\\"selectedTab === i\\\" [color]=\\\"tabsColor\\\"\\n                            [badgeColor]=\\\"badgeColor\\\"></super-tab-button>\\n        </div>\\n        <div *ngIf=\\\"tabsPlacement === 'top'\\\" class=\\\"indicator {{ 'button-md-' + indicatorColor }}\\\" #indicator></div>\\n      </div>\\n    </ion-toolbar>\\n  \",\n                    encapsulation: ViewEncapsulation.None\n                },] },\n    ];\n    /** @nocollapse */\n    SuperTabsToolbar.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: Platform, },\n        { type: Renderer2, },\n        { type: DomController, },\n    ]; };\n    SuperTabsToolbar.propDecorators = {\n        'color': [{ type: Input },],\n        'tabsColor': [{ type: Input },],\n        'badgeColor': [{ type: Input },],\n        'scrollTabs': [{ type: Input },],\n        'indicatorColor': [{ type: Input },],\n        'selectedTab': [{ type: Input },],\n        'config': [{ type: Input },],\n        'tabsPlacement': [{ type: Input },],\n        'tabSelect': [{ type: Output },],\n        'tabButtons': [{ type: ViewChildren, args: [SuperTabButton,] },],\n        'tabButtonsContainer': [{ type: ViewChild, args: ['tabButtonsContainer',] },],\n        'indicator': [{ type: ViewChild, args: ['indicator',] },],\n        'tabButtonsBar': [{ type: ViewChild, args: ['tabButtons',] },],\n    };\n    return SuperTabsToolbar;\n}());\nexport { SuperTabsToolbar };\n//# sourceMappingURL=super-tabs-toolbar.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ionic2-super-tabs/dist/components/super-tabs-toolbar.js\n// module id = 288\n// module chunks = 0","import { pointerCoord } from 'ionic-angular/util/dom';\nvar SuperTabsPanGesture = (function () {\n    function SuperTabsPanGesture(plt, el, config, rnd) {\n        this.plt = plt;\n        this.el = el;\n        this.config = config;\n        this.rnd = rnd;\n        this.leftThreshold = 0;\n        this.rightThreshold = 0;\n        this.listeners = [];\n        this.listeners.push(rnd.listen(el, 'touchstart', this._onStart.bind(this)), rnd.listen(el, 'touchmove', this._onMove.bind(this)), rnd.listen(el, 'touchend', this._onEnd.bind(this)));\n        if (config.sideMenu === 'both' || config.sideMenu === 'left') {\n            this.leftThreshold = config.sideMenuThreshold;\n        }\n        if (config.sideMenu === 'both' || config.sideMenu === 'right') {\n            this.rightThreshold = config.sideMenuThreshold;\n        }\n    }\n    SuperTabsPanGesture.prototype.destroy = function () {\n        this.listeners.forEach(function (fn) { return fn(); });\n    };\n    SuperTabsPanGesture.prototype._onStart = function (ev) {\n        // check avoid this element\n        var avoid = false;\n        var element = ev.target;\n        if (element) {\n            do {\n                if (element.getAttribute && element.getAttribute('avoid-super-tabs'))\n                    avoid = true;\n                element = element.parentElement;\n            } while (element && !avoid);\n        }\n        if (avoid) {\n            this.shouldCapture = false;\n            return;\n        }\n        var coords = pointerCoord(ev), vw = this.plt.width();\n        if (coords.x < this.leftThreshold || coords.x > vw - this.rightThreshold) {\n            // ignore this gesture, it started in the side menu touch zone\n            this.shouldCapture = false;\n            return;\n        }\n        // the starting point looks good, let's see what happens when we move\n        this.initialCoords = coords;\n        if (this.config.shortSwipeDuration > 0)\n            this.initialTimestamp = Date.now();\n        this.lastPosX = coords.x;\n    };\n    SuperTabsPanGesture.prototype._onMove = function (ev) {\n        var coords = pointerCoord(ev);\n        if (!this.isDragging) {\n            if (typeof this.shouldCapture !== 'boolean')\n                // we haven't decided yet if we want to capture this gesture\n                this.checkGesture(coords);\n            if (this.shouldCapture === true)\n                // gesture is good, let's capture all next onTouchMove events\n                this.isDragging = true;\n            else\n                return;\n        }\n        // stop anything else from capturing these events, to make sure the content doesn't slide\n        if (this.config.allowElementScroll !== true) {\n            ev.stopPropagation();\n            ev.preventDefault();\n        }\n        // get delta X\n        var deltaX = this.lastPosX - coords.x;\n        // emit value\n        this.onMove && this.onMove(deltaX);\n        // update last X value\n        this.lastPosX = coords.x;\n    };\n    SuperTabsPanGesture.prototype._onEnd = function (ev) {\n        var coords = pointerCoord(ev);\n        if (this.shouldCapture === true) {\n            if (this.config.shortSwipeDuration > 0) {\n                var deltaTime = Date.now() - this.initialTimestamp;\n                if (deltaTime <= this.config.shortSwipeDuration)\n                    this.onEnd && this.onEnd(true, coords.x - this.initialCoords.x);\n                else\n                    this.onEnd && this.onEnd(false);\n            }\n            else\n                this.onEnd && this.onEnd(false);\n        }\n        this.isDragging = false;\n        this.shouldCapture = undefined;\n    };\n    SuperTabsPanGesture.prototype.checkGesture = function (newCoords) {\n        if (!this.initialCoords)\n            return;\n        var radians = this.config.maxDragAngle * (Math.PI / 180), maxCosine = Math.cos(radians), deltaX = newCoords.x - this.initialCoords.x, deltaY = newCoords.y - this.initialCoords.y, distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n        if (distance >= this.config.dragThreshold) {\n            // swipe is long enough so far\n            // lets check the angle\n            var angle = Math.atan2(deltaY, deltaX), cosine = Math.cos(angle);\n            this.shouldCapture = Math.abs(cosine) > maxCosine;\n        }\n    };\n    return SuperTabsPanGesture;\n}());\nexport { SuperTabsPanGesture };\n//# sourceMappingURL=super-tabs-pan-gesture.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ionic2-super-tabs/dist/super-tabs-pan-gesture.js\n// module id = 289\n// module chunks = 0","import { ChangeDetectionStrategy, Component, ElementRef, EventEmitter, Input, Output, ViewEncapsulation } from '@angular/core';\nvar SuperTabButton = (function () {\n    function SuperTabButton(_el) {\n        this._el = _el;\n        this.selected = false;\n        this.select = new EventEmitter();\n    }\n    SuperTabButton.prototype.onClick = function () {\n        this.select.emit(this);\n    };\n    SuperTabButton.prototype.getNativeElement = function () {\n        return this._el.nativeElement;\n    };\n    SuperTabButton.decorators = [\n        { type: Component, args: [{\n                    selector: 'super-tab-button',\n                    template: \"\\n    <ion-icon *ngIf=\\\"!!icon\\\" [name]=\\\"icon\\\" [color]=\\\"color\\\"></ion-icon>\\n    <span class=\\\"title\\\" *ngIf=\\\"!!title\\\" ion-text [color]=\\\"color\\\">{{ title }}</span>\\n    <ion-badge mode=\\\"md\\\" [color]=\\\"badgeColor\\\">{{ badge }}</ion-badge>\\n    <div class=\\\"button-effect\\\"></div>\\n  \",\n                    host: {\n                        '[class.selected]': 'selected',\n                        '(click)': 'onClick()',\n                        '[class.title-only]': '!!title && !icon',\n                        '[class.icon-only]': '!title && !!icon',\n                        '[class.title-and-icon]': '!!title && !!icon',\n                        'tappable': '',\n                        'role': 'button'\n                    },\n                    changeDetection: ChangeDetectionStrategy.OnPush,\n                    encapsulation: ViewEncapsulation.None\n                },] },\n    ];\n    /** @nocollapse */\n    SuperTabButton.ctorParameters = function () { return [\n        { type: ElementRef, },\n    ]; };\n    SuperTabButton.propDecorators = {\n        'selected': [{ type: Input },],\n        'title': [{ type: Input },],\n        'icon': [{ type: Input },],\n        'badge': [{ type: Input },],\n        'badgeColor': [{ type: Input },],\n        'color': [{ type: Input },],\n        'select': [{ type: Output },],\n    };\n    return SuperTabButton;\n}());\nexport { SuperTabButton };\n//# sourceMappingURL=super-tab-button.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ionic2-super-tabs/dist/components/super-tab-button.js\n// module id = 290\n// module chunks = 0","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [0, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { Component, ElementRef, EventEmitter, Input, NgZone, Output, Renderer2, ViewChild, ViewEncapsulation } from '@angular/core';\nimport { Platform } from 'ionic-angular';\nimport { SuperTabsPanGesture } from '../super-tabs-pan-gesture';\nvar SuperTabsContainer = (function () {\n    function SuperTabsContainer(el, rnd, plt, ngZone) {\n        this.el = el;\n        this.rnd = rnd;\n        this.plt = plt;\n        this.ngZone = ngZone;\n        /**\n         * Number of tabs\n         * @type {number}\n         */\n        this.tabsCount = 0;\n        /**\n         * Notifies when a tab is selected\n         * @type {EventEmitter<Object>}\n         */\n        this.tabSelect = new EventEmitter();\n        /**\n         * Notifies when the container is being dragged\n         * @type {EventEmitter<TouchEvent>}\n         */\n        this.onDrag = new EventEmitter();\n        // View bindings\n        /**\n         * Container position\n         * @type {number}\n         */\n        this.containerPosition = 0;\n        /**\n         * Single tab width\n         * @type {number}\n         */\n        this.tabWidth = 0;\n        /**\n         * Container width (sum of tab widths)\n         * @type {number}\n         */\n        this.containerWidth = 0;\n        /**\n         * Boolean indicating whether swiping is globally enabled\n         * @type {boolean}\n         */\n        this.globalSwipeEnabled = true;\n        /**\n         * Set of booleans to indicate whether swiping is enabled on each tab\n         * @type {{}}\n         */\n        this.swipeEnabledPerTab = {};\n    }\n    SuperTabsContainer.prototype.ngAfterViewInit = function () {\n        this.init();\n    };\n    SuperTabsContainer.prototype.ngOnDestroy = function () {\n        this.gesture && this.gesture.destroy();\n    };\n    /**\n     * Enable or disable swiping globally\n     * @param enable {boolean} set to true to enable\n     */\n    SuperTabsContainer.prototype.enableTabsSwipe = function (enable) {\n        this.globalSwipeEnabled = enable;\n    };\n    /**\n     * Enable or disable swiping when a tab is selected\n     * @param tabIndex {number} tab index\n     * @param enable {boolean} set to true to enable\n     */\n    SuperTabsContainer.prototype.enableTabSwipe = function (tabIndex, enable) {\n        this.swipeEnabledPerTab[tabIndex] = enable;\n    };\n    SuperTabsContainer.prototype.refreshDimensions = function () {\n        this.calculateContainerWidth();\n        this.setContainerWidth();\n        this.refreshMinMax();\n    };\n    SuperTabsContainer.prototype.getNativeElement = function () {\n        return this.el.nativeElement;\n    };\n    SuperTabsContainer.prototype.init = function () {\n        var _this = this;\n        this.refreshDimensions();\n        this.gesture = new SuperTabsPanGesture(this.plt, this.container.nativeElement, this.config, this.rnd);\n        this.gesture.onMove = function (delta) {\n            if (_this.globalSwipeEnabled === false)\n                return;\n            if (_this.swipeEnabledPerTab[_this.selectedTabIndex] === false)\n                return;\n            if ((_this.containerPosition === _this.maxPosX && delta >= 0) || (_this.containerPosition === _this.minPosX && delta <= 0))\n                return;\n            _this.containerPosition += delta;\n            _this.plt.raf(function () {\n                _this.onDrag.emit();\n                _this.moveContainer();\n            });\n        };\n        this.gesture.onEnd = function (shortSwipe, shortSwipeDelta) {\n            if (_this.globalSwipeEnabled === false)\n                return;\n            if (_this.swipeEnabledPerTab[_this.selectedTabIndex] === false)\n                return;\n            // get tab index based on container position\n            var tabIndex = Math.round(_this.containerPosition / _this.tabWidth);\n            // handle short swipes\n            // only short swipe if we didn't change tab already in this gesture\n            (tabIndex === _this.selectedTabIndex) && shortSwipe && ((shortSwipeDelta < 0 && tabIndex++) || (shortSwipeDelta > 0 && tabIndex--));\n            // get location based on tab index\n            var position = Math.max(_this.minPosX, Math.min(_this.maxPosX, tabIndex * _this.tabWidth));\n            tabIndex = position / _this.tabWidth;\n            // move container if we changed position\n            if (position !== _this.containerPosition) {\n                _this.plt.raf(function () {\n                    return _this.moveContainer(true, position)\n                        .then(function () {\n                        return _this.ngZone.run(function () { return _this.setSelectedTab(tabIndex); });\n                    });\n                });\n            }\n            else\n                _this.setSelectedTab(tabIndex);\n        };\n    };\n    /**\n     * Set the selected tab.\n     * Emits a tabSelect event with the tab index, and a boolean indicating whether the tab changed or not.\n     * @param index {number} tab index\n     */\n    SuperTabsContainer.prototype.setSelectedTab = function (index) {\n        this.tabSelect.emit({ index: index, changed: index !== this.selectedTabIndex });\n        this.selectedTabIndex = index;\n    };\n    /**\n     * Calculate the container's width.\n     * It's usually the number of tabs x tab width.\n     */\n    SuperTabsContainer.prototype.calculateContainerWidth = function () {\n        this.containerWidth = this.tabWidth * this.tabsCount;\n    };\n    /**\n     * Set the container's width via CSS property\n     */\n    SuperTabsContainer.prototype.setContainerWidth = function () {\n        this.rnd.setStyle(this.container.nativeElement, 'width', this.containerWidth + 'px');\n    };\n    /**\n     * Slide to a specific tab\n     * @param index {number} tab index\n     * @param [animate=true] {boolean} set to true to animate\n     */\n    SuperTabsContainer.prototype.slideTo = function (index, animate) {\n        var _this = this;\n        if (animate === void 0) { animate = true; }\n        this.plt.raf(function () { return _this.moveContainer(animate, index * _this.tabWidth); });\n    };\n    /**\n     * Moves the container to a specified position\n     * @param [animate=false] {boolean} set to true to animate\n     * @param [positionX] {number} position on x-axis\n     */\n    SuperTabsContainer.prototype.moveContainer = function (animate, positionX) {\n        if (animate === void 0) { animate = false; }\n        return __awaiter(this, void 0, void 0, function () {\n            var el;\n            return __generator(this, function (_a) {\n                el = this.container.nativeElement;\n                if (animate) {\n                    if (el.style[this.plt.Css.transform].indexOf('all') === -1) {\n                        this.rnd.setStyle(el, this.plt.Css.transition, \"all \" + this.config.transitionDuration + \"ms \" + this.config.transitionEase);\n                    }\n                    this.rnd.setStyle(el, this.plt.Css.transform, \"translate3d(\" + -1 * positionX + \"px, 0, 0)\");\n                    this.containerPosition = positionX;\n                }\n                else {\n                    if (positionX) {\n                        this.containerPosition = positionX;\n                    }\n                    if (el.style[this.plt.Css.transform] !== 'initial') {\n                        this.rnd.setStyle(el, this.plt.Css.transition, 'initial');\n                    }\n                    this.containerPosition = Math.max(this.minPosX, Math.min(this.maxPosX, this.containerPosition));\n                    this.rnd.setStyle(el, this.plt.Css.transform, \"translate3d(\" + -1 * this.containerPosition + \"px, 0, 0)\");\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    /**\n     * Refresh the min and max positions that the container can be at.\n     * The minimum position is always 0, the maximum position is the number of tabs x tab width.\n     */\n    SuperTabsContainer.prototype.refreshMinMax = function () {\n        this.minPosX = 0;\n        this.maxPosX = (this.tabsCount - 1) * this.tabWidth;\n    };\n    SuperTabsContainer.decorators = [\n        { type: Component, args: [{\n                    selector: 'super-tabs-container',\n                    template: '<div #container><ng-content></ng-content></div>',\n                    encapsulation: ViewEncapsulation.None\n                },] },\n    ];\n    /** @nocollapse */\n    SuperTabsContainer.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: Renderer2, },\n        { type: Platform, },\n        { type: NgZone, },\n    ]; };\n    SuperTabsContainer.propDecorators = {\n        'config': [{ type: Input },],\n        'tabsCount': [{ type: Input },],\n        'selectedTabIndex': [{ type: Input },],\n        'tabSelect': [{ type: Output },],\n        'onDrag': [{ type: Output },],\n        'container': [{ type: ViewChild, args: ['container',] },],\n    };\n    return SuperTabsContainer;\n}());\nexport { SuperTabsContainer };\n//# sourceMappingURL=super-tabs-container.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ionic2-super-tabs/dist/components/super-tabs-container.js\n// module id = 291\n// module chunks = 0","\"use strict\";\nvar AsyncAction_1 = require('./AsyncAction');\nvar AsyncScheduler_1 = require('./AsyncScheduler');\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asap} scheduler.\n *\n * @example <caption>Use async scheduler to delay task</caption>\n * const task = () => console.log('it works!');\n *\n * Rx.Scheduler.async.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n *\n *\n * @example <caption>Use async scheduler to repeat task in intervals</caption>\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * Rx.Scheduler.async.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n *\n * @static true\n * @name async\n * @owner Scheduler\n */\nexports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);\n//# sourceMappingURL=async.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/scheduler/async.js\n// module id = 292\n// module chunks = 0","import {Component, ViewChild} from '@angular/core';\nimport {IonicPage, Navbar, NavController, NavParams} from 'ionic-angular';\nimport {ProductListPage} from \"../product-list/product-list\";\nimport {SuperTabs} from \"ionic2-super-tabs\";\n\n/**\n * Generated class for the ProductPage page.\n *\n * See https://ionicframework.com/docs/components/#navigation for more info on\n * Ionic pages and navigation.\n */\n\n@IonicPage()\n@Component({\n  selector: 'page-product',\n  templateUrl: 'product.html',\n})\nexport class ProductPage {\n\n  title;\n  showMenu: boolean = true;\n  productList = ProductListPage;\n\n  data = [{name: '全部', key: 'all'}];\n  @ViewChild(Navbar) navBar: Navbar;\n  @ViewChild(SuperTabs) superTabs: SuperTabs;\n\n  constructor(public navCtrl: NavController, public navParams: NavParams) {\n    this.title = navParams.get('title');\n    let {data = this.data} = {data: navParams.get('data')};\n    this.data = data;\n  }\n\n  ionViewDidLoad() {\n    console.log('ionViewDidLoad ProductPage');\n    this.navBar.setBackButtonText(\"\");\n    this.superTabs.showToolbar(this.superTabs.getAllChildNavs().length > 1);\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/pages/product/product.ts","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar fromEvent_1 = require('../../observable/fromEvent');\nObservable_1.Observable.fromEvent = fromEvent_1.fromEvent;\n//# sourceMappingURL=fromEvent.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/observable/fromEvent.js\n// module id = 299\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar merge_1 = require('../../observable/merge');\nObservable_1.Observable.merge = merge_1.merge;\n//# sourceMappingURL=merge.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/observable/merge.js\n// module id = 300\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar debounceTime_1 = require('../../operator/debounceTime');\nObservable_1.Observable.prototype.debounceTime = debounceTime_1.debounceTime;\n//# sourceMappingURL=debounceTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/operator/debounceTime.js\n// module id = 301\n// module chunks = 0","\"use strict\";\nvar async_1 = require('../scheduler/async');\nvar debounceTime_1 = require('../operators/debounceTime');\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\n * managing timers.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounceTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nfunction debounceTime(dueTime, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return debounceTime_1.debounceTime(dueTime, scheduler)(this);\n}\nexports.debounceTime = debounceTime;\n//# sourceMappingURL=debounceTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/debounceTime.js\n// module id = 302\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = require('../util/root');\nvar Action_1 = require('./Action');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AsyncAction = (function (_super) {\n    __extends(AsyncAction, _super);\n    function AsyncAction(scheduler, work) {\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n        this.pending = false;\n    }\n    AsyncAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (this.closed) {\n            return this;\n        }\n        // Always replace the current state with the new state.\n        this.state = state;\n        // Set the pending flag indicating that this action has been scheduled, or\n        // has recursively rescheduled itself.\n        this.pending = true;\n        var id = this.id;\n        var scheduler = this.scheduler;\n        //\n        // Important implementation note:\n        //\n        // Actions only execute once by default, unless rescheduled from within the\n        // scheduled callback. This allows us to implement single and repeat\n        // actions via the same code path, without adding API surface area, as well\n        // as mimic traditional recursion but across asynchronous boundaries.\n        //\n        // However, JS runtimes and timers distinguish between intervals achieved by\n        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n        // serial `setTimeout` calls can be individually delayed, which delays\n        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n        // guarantee the interval callback will be invoked more precisely to the\n        // interval period, regardless of load.\n        //\n        // Therefore, we use `setInterval` to schedule single and repeat actions.\n        // If the action reschedules itself with the same delay, the interval is not\n        // canceled. If the action doesn't reschedule, or reschedules with a\n        // different delay, the interval will be canceled after scheduled callback\n        // execution.\n        //\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, delay);\n        }\n        this.delay = delay;\n        // If this action has already an async Id, don't request a new one.\n        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n        return this;\n    };\n    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);\n    };\n    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If this action is rescheduled with the same delay time, don't clear the interval id.\n        if (delay !== null && this.delay === delay && this.pending === false) {\n            return id;\n        }\n        // Otherwise, if the action's delay time is different from the current delay,\n        // or the action has been rescheduled before it's executed, clear the interval id\n        return root_1.root.clearInterval(id) && undefined || undefined;\n    };\n    /**\n     * Immediately executes this action and the `work` it contains.\n     * @return {any}\n     */\n    AsyncAction.prototype.execute = function (state, delay) {\n        if (this.closed) {\n            return new Error('executing a cancelled action');\n        }\n        this.pending = false;\n        var error = this._execute(state, delay);\n        if (error) {\n            return error;\n        }\n        else if (this.pending === false && this.id != null) {\n            // Dequeue if the action didn't reschedule itself. Don't call\n            // unsubscribe(), because the action could reschedule later.\n            // For example:\n            // ```\n            // scheduler.schedule(function doWork(counter) {\n            //   /* ... I'm a busy worker bee ... */\n            //   var originalAction = this;\n            //   /* wait 100ms before rescheduling the action */\n            //   setTimeout(function () {\n            //     originalAction.schedule(counter + 1);\n            //   }, 100);\n            // }, 1000);\n            // ```\n            this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n        }\n    };\n    AsyncAction.prototype._execute = function (state, delay) {\n        var errored = false;\n        var errorValue = undefined;\n        try {\n            this.work(state);\n        }\n        catch (e) {\n            errored = true;\n            errorValue = !!e && e || new Error(e);\n        }\n        if (errored) {\n            this.unsubscribe();\n            return errorValue;\n        }\n    };\n    /** @deprecated internal use only */ AsyncAction.prototype._unsubscribe = function () {\n        var id = this.id;\n        var scheduler = this.scheduler;\n        var actions = scheduler.actions;\n        var index = actions.indexOf(this);\n        this.work = null;\n        this.state = null;\n        this.pending = false;\n        this.scheduler = null;\n        if (index !== -1) {\n            actions.splice(index, 1);\n        }\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, null);\n        }\n        this.delay = null;\n    };\n    return AsyncAction;\n}(Action_1.Action));\nexports.AsyncAction = AsyncAction;\n//# sourceMappingURL=AsyncAction.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/scheduler/AsyncAction.js\n// module id = 303\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = require('../Subscription');\n/**\n * A unit of work to be executed in a {@link Scheduler}. An action is typically\n * created from within a Scheduler and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nvar Action = (function (_super) {\n    __extends(Action, _super);\n    function Action(scheduler, work) {\n        _super.call(this);\n    }\n    /**\n     * Schedules this action on its parent Scheduler for execution. May be passed\n     * some context object, `state`. May happen at some point in the future,\n     * according to the `delay` parameter, if specified.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler.\n     * @return {void}\n     */\n    Action.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        return this;\n    };\n    return Action;\n}(Subscription_1.Subscription));\nexports.Action = Action;\n//# sourceMappingURL=Action.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/scheduler/Action.js\n// module id = 304\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Scheduler_1 = require('../Scheduler');\nvar AsyncScheduler = (function (_super) {\n    __extends(AsyncScheduler, _super);\n    function AsyncScheduler() {\n        _super.apply(this, arguments);\n        this.actions = [];\n        /**\n         * A flag to indicate whether the Scheduler is currently executing a batch of\n         * queued actions.\n         * @type {boolean}\n         */\n        this.active = false;\n        /**\n         * An internal ID used to track the latest asynchronous task such as those\n         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n         * others.\n         * @type {any}\n         */\n        this.scheduled = undefined;\n    }\n    AsyncScheduler.prototype.flush = function (action) {\n        var actions = this.actions;\n        if (this.active) {\n            actions.push(action);\n            return;\n        }\n        var error;\n        this.active = true;\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (action = actions.shift()); // exhaust the scheduler queue\n        this.active = false;\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsyncScheduler;\n}(Scheduler_1.Scheduler));\nexports.AsyncScheduler = AsyncScheduler;\n//# sourceMappingURL=AsyncScheduler.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/scheduler/AsyncScheduler.js\n// module id = 305\n// module chunks = 0","\"use strict\";\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an {@link Action}.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n */\nvar Scheduler = (function () {\n    function Scheduler(SchedulerAction, now) {\n        if (now === void 0) { now = Scheduler.now; }\n        this.SchedulerAction = SchedulerAction;\n        this.now = now;\n    }\n    /**\n     * Schedules a function, `work`, for execution. May happen at some point in\n     * the future, according to the `delay` parameter, if specified. May be passed\n     * some context object, `state`, which will be passed to the `work` function.\n     *\n     * The given arguments will be processed an stored as an Action object in a\n     * queue of actions.\n     *\n     * @param {function(state: ?T): ?Subscription} work A function representing a\n     * task, or some unit of work to be executed by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler itself.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @return {Subscription} A subscription in order to be able to unsubscribe\n     * the scheduled work.\n     */\n    Scheduler.prototype.schedule = function (work, delay, state) {\n        if (delay === void 0) { delay = 0; }\n        return new this.SchedulerAction(this, work).schedule(state, delay);\n    };\n    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };\n    return Scheduler;\n}());\nexports.Scheduler = Scheduler;\n//# sourceMappingURL=Scheduler.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/Scheduler.js\n// module id = 306\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar async_1 = require('../scheduler/async');\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\n * managing timers.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounceTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nfunction debounceTime(dueTime, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };\n}\nexports.debounceTime = debounceTime;\nvar DebounceTimeOperator = (function () {\n    function DebounceTimeOperator(dueTime, scheduler) {\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n    }\n    DebounceTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n    };\n    return DebounceTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DebounceTimeSubscriber = (function (_super) {\n    __extends(DebounceTimeSubscriber, _super);\n    function DebounceTimeSubscriber(destination, dueTime, scheduler) {\n        _super.call(this, destination);\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n        this.debouncedSubscription = null;\n        this.lastValue = null;\n        this.hasValue = false;\n    }\n    DebounceTimeSubscriber.prototype._next = function (value) {\n        this.clearDebounce();\n        this.lastValue = value;\n        this.hasValue = true;\n        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n    };\n    DebounceTimeSubscriber.prototype._complete = function () {\n        this.debouncedNext();\n        this.destination.complete();\n    };\n    DebounceTimeSubscriber.prototype.debouncedNext = function () {\n        this.clearDebounce();\n        if (this.hasValue) {\n            this.destination.next(this.lastValue);\n            this.lastValue = null;\n            this.hasValue = false;\n        }\n    };\n    DebounceTimeSubscriber.prototype.clearDebounce = function () {\n        var debouncedSubscription = this.debouncedSubscription;\n        if (debouncedSubscription !== null) {\n            this.remove(debouncedSubscription);\n            debouncedSubscription.unsubscribe();\n            this.debouncedSubscription = null;\n        }\n    };\n    return DebounceTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNext(subscriber) {\n    subscriber.debouncedNext();\n}\n//# sourceMappingURL=debounceTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/debounceTime.js\n// module id = 307\n// module chunks = 0","import { NgModule } from '@angular/core';\nimport { IonicModule } from 'ionic-angular';\nimport { SuperTab } from './components/super-tab';\nimport { SuperTabs } from './components/super-tabs';\nimport { SuperTabsController } from './providers/super-tabs-controller';\nimport { SuperTabsToolbar } from './components/super-tabs-toolbar';\nimport { SuperTabsContainer } from './components/super-tabs-container';\nimport { SuperTabButton } from './components/super-tab-button';\nvar SuperTabsModule = (function () {\n    function SuperTabsModule() {\n    }\n    SuperTabsModule.forRoot = function () {\n        return {\n            ngModule: SuperTabsModule,\n            providers: [\n                SuperTabsController\n            ]\n        };\n    };\n    SuperTabsModule.decorators = [\n        { type: NgModule, args: [{\n                    declarations: [\n                        SuperTab,\n                        SuperTabs,\n                        SuperTabsToolbar,\n                        SuperTabsContainer,\n                        SuperTabButton\n                    ],\n                    imports: [\n                        IonicModule\n                    ],\n                    exports: [\n                        SuperTab,\n                        SuperTabs\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    SuperTabsModule.ctorParameters = function () { return []; };\n    return SuperTabsModule;\n}());\nexport { SuperTabsModule };\n//# sourceMappingURL=super-tabs.module.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ionic2-super-tabs/dist/super-tabs.module.js\n// module id = 308\n// module chunks = 0"],"sourceRoot":""}